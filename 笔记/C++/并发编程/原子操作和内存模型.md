# 原子操作
一个原子类型我们可以查看一个类型是不是线程安全的，通过`std::atomic::is_lock_free`
比如：
```c++
#include <atomic>
#include <iostream>
  
std::atomic<int> a;

int main(){

    a = 0;
    std::cout << a.is_lock_free() << std::endl;
    return 0;
}
```
如果返回1， 则说明这个类型在当前硬件上是原子的，也就是所有操作无需加锁，如果返回false，则需要我们手动添加锁结构

但是有一个原子类型没有`is_lock_free`函数，就是`std::atomic_flag`，这是一个原子标记，这个类型在初始化时会被自动的置0，随后我们可以通过`test_and_set`来置1，使用`clear`来清零。如果`test_and_set`不是阻塞的，如果原来是值是0，就返回0，如果是1，返回值就是1。
`std::atomic_flag`是自旋锁实现的基础，也是所有原子类型实现的基础

对于普通的`std::atomic<T>`类型的原子变量，还支持
* load()            加载（读取）
* store()          存储（赋值）
* exchange()      （值交换）
* compare_exchange_weak()      和期望值相比，如果不等就交换
* compre_exchanged_strong()

# 内存次序
对于原子类型上的每一种操作，ye'jiu's，我们都可以提供额外的参数，从枚举类`std::memory_order`取值，用于设定所需的内存次序语义
枚举类`std::memory_order`有6个可能的取值
* std::memory_order_relexed     宽松内存结构，只保证内存的原子性,
* std::memory_order_acquire
* std::memory_order_consume
* std::memory_order_acq_rel
* std::memory_order_release
* std::memory_order_seq_cst      保证全局值相同,这是默认的参数
