# 原子操作
一个原子类型我们可以查看一个类型是不是线程安全的，通过`std::atomic::is_lock_free`
比如：
```c++
#include <atomic>
#include <iostream>
  
std::atomic<int> a;

int main(){

    a = 0;
    std::cout << a.is_lock_free() << std::endl;
    return 0;
}
```
如果返回1， 则说明这个类型在当前硬件上是原子的，也就是所有操作无需加锁，如果返回false，则需要我们手动添加锁结构

但是有一个原子类型没有`is_lock_free`函数，就是`std::atomic_flag`，这是一个原子标记，这个类型在初始化时会被自动的置0，随后我们可以通过`test_and_set`来置1，使用`clear`来清零。如果`test_and_set`不是阻塞的，如果原来是值是0，就返回0，如果是1，返回值就是1。
`std::atomic_flag`是自旋锁实现的基础，也是所有原子类型实现的基础

对于普通的`std::atomic<T>`类型的原子变量，还支持
* load()            加载（读取）
* store()          存储（赋值）
* exchange()      （值交换）
* compare_exchange_weak()      和期望zh
* compre_exchanged_strong()