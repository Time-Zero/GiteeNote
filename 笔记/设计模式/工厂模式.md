# 简单工厂
定义抽象产品类，子类继承抽象产品类来实现自己的产品
通过一个中央工厂来实现具体产品的生产
```C++
#include <iostream>
using namespace std;

//抽象产品
class AbstractPorduct{
public:
    virtual ~AbstractPorduct(){};
    virtual void MakeProduct() = 0;    
};

// 具体产品：飞机
class PlaneProduct : public AbstractPorduct{
    ~PlaneProduct(){};
    void MakeProduct() override{
        cout << "Plane" << endl;
    }
};

// 具体产品：火箭
class RocketProduct : public AbstractPorduct{
    ~RocketProduct(){};
    void MakeProduct() override{
        cout << "Rocket" << endl;
    }
};

// 工厂类，负责生产具体产品
class Factory{
    public:
    enum ProductType {Plane, Rocket};

    static AbstractPorduct* CreateProduct(ProductType type){
        switch (type) {
            case Factory::ProductType::Plane:
                return new PlaneProduct;
            case Factory::ProductType::Rocket:
                return new RocketProduct;
        }
    }
};
```

# 多态工厂
声明抽象产品类，具体产品类继承抽象产品
声明抽象工厂类，具体工厂继承抽象工厂
一个具体工厂生产一种具体产品

```C++
#include <iostream>
using namespace std;

class AbstractProduct{
public:
    virtual void MakeProduct() = 0;
}; 

class AbstractFactory{
public:
    virtual AbstractProduct* CreateProduct() = 0;
};

class PlaneProduct : public AbstractProduct{
public:
    void MakeProduct() override{
        cout << "Plane" << endl;
    }
};

class RocketProduct: public AbstractProduct{
public:
    void MakeProduct() override{
        cout << "Rocket" << endl;
    }
};

class PlaneFactory: public AbstractFactory{
public:
    AbstractProduct* CreateProduct() override{
        return new PlaneProduct;
    }
};

class RocketFactory: public AbstractFactory{
public:
    AbstractProduct* CreateProduct() override{
        return new RocketProduct;
    }
};
```

## 优缺点
### 优点
* 需求改变时改动最小
* 创建过程和客户端分离

### 缺点
* 实现一个新的产品时，工作量稍大

# 抽象工厂
在多态工厂上做了改动
在抽象产品类后又封装了一个抽象产品族，使得抽象工厂类可以生产多种产品
