# 现象
Epoll的惊群和我们C++常用的条件变量也就是condition_variable的惊群差不多。其发生的场景如下：
1. 我们首先创建一个用于监听客户端连接的socket
2. 我们将这个socket设置为listen状态
3. 我们将这个socket加入到一个epoll中
4. 我们在拥有这个epoll的主线程中调用fork函数，创建多个线程
这时，如果客户端发送一个连接请求，惊群现象就可能发生。

# 原理
Epoll惊群的原理就是我们创建并且监听了一个socket，并把这个socket同时放到了Epoll中，并且使用fork创建了多个进程。

由于fork的原理是将调用fork的进程基本上完全复制一遍来创建新的进程，所以原来线程拥有的不管是文件描述符还是内存空间等，子线程和父线程基本完全一致

所以当客户端发送新的socket连接请求到server时，由于多个线程都拥有epoll的文件描述符（inode），或许都调用着epoll_wait来获取epoll事件，这时候就可能会发生多个进程同时获取到了这个连接事件，而让epoll_wait返回，让多个进程从等待的阻塞态到活动态，但是由于socket连接请求只能由一个进程accept，这就造成了别的监听进程的没有作用的唤醒，造成资源的浪费。