# 现象
Epoll的惊群和我们C++常用的条件变量也就是condition_variable的惊群差不多。其发生的场景如下：
1. 我们首先创建一个用于监听客户端连接的socket
2. 我们将这个socket设置为listen状态
3. 我们将这个socket加入到一个epoll中
4. 我们在拥有这个epoll的主线程中调用fork函数，创建多个线程
这时，如果客户端发送一个连接请求，惊群现象就可能发生。

# 原理
## 原始版本
Epoll惊群的原理就是我们创建并且监听了一个socket，并把这个socket同时放到了Epoll中，并且使用fork创建了多个进程。

由于fork的原理是将调用fork的进程基本上完全复制一遍来创建新的进程，所以原来线程拥有的不管是文件描述符还是内存空间等，子线程和父线程基本完全一致

所以当客户端发送新的socket连接请求到server时，由于多个线程都拥有epoll的文件描述符（inode），或许都调用着epoll_wait来获取epoll事件，这时候就可能会发生多个进程同时获取到了这个连接事件，而让epoll_wait返回，让多个进程从等待的阻塞态到活动态，但是由于socket连接请求只能由一个进程accept，这就造成了别的监听进程的没有作用的唤醒，造成资源的浪费。

当然，惊群不仅可以出现在进程环境，**==如果多个线程同时监听一个epoll中的同一个FD，或者是不同Epoll中的一个FD==**，也可能会出现这种情况


## 另一个版本
还有一种惊群和Epoll的触发模式有关，如果Epoll是水平触发模式（LT），当事件到来时，只要没有被处理，就会被一直触发。

在epoll LT模式下，如果事件来了，只要还没有处理，epoll都会通知你。epoll_wait在取到事件的时候并不会马上调用accept，此时还在子函数ep_poll中，因为此时事件并没有被处理掉，系统会继续唤醒别的进程来准备处理这个事件，存在多个进程被唤醒处理一个事件，这就是epoll中的惊群效应。
# 解决
## 普遍解决

解决该问题的方法比较简单，使不同进程的epoll_wait互斥调用即可，具体如下：

* 使用边缘触发EPOLLET模式：边缘触发模式下，只有当文件描述符状态发生变化时才会被唤醒，可以有效避免惊群效应。

* 使用epoll的EPOLLONESHOT事件：EPOLLONESHOT事件可以保证每个文件描述符只被唤醒一次，需要重新注册到epoll中才能再次被触发。

* 使用EPOLLEXCLUSIVE：使用EPOLLEXCLUSIVE可以保证只有一个进程或线程被唤醒并处理就绪事件，其他等待此事件就绪的进程或线程不会被唤醒，从而避免了惊群效应。（Note：EPOLLEXCLUSIVE只能在ET模式下使用，且对性能具有一定损耗，谨慎使用）

## Linux内核解决
根本原因在于epoll的默认行为是对于多进程监听同一文件不会设置互斥，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案
1. 既然默认不会设置互斥，那就加一个==互斥==功能好了:-)，linux4.5内核之后给epoll添加了一个EPOLLEXCLUSIVE的标志位，如果设置了这个标志位，那epoll将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生accept一样的特性，只会唤醒队列中的一个进程
2. 第二种方法：linux 3.9内核之后给socket提供SO_REUSEPORT标志，这种方式解决得更彻底，他允许==不同进程的socket绑定到同一个端口==（端口复用），取代以往需要子进程共享socket监听的方式，这时候，每个进程的监听socket将指向open_file_tables下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享fd的问题，也就不存在被同时唤醒的可能时，而内核则在驱动中将设置了SO_REUSEPORT并且绑定同一端口的这些socket分到同一个group中，当有tcp连接事件到达的时候，内核将会对源IP+源端口取hash然后指定这个group中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡