# 总体概述
## 十大数据类型
* string
* bitmap
* bitfield
* hash
* list
* set
* sorted set (zset)
* geospatial（GEO）
* hyperlog
* stream

## 说明
redis是k-v数据库，前面的十大数据类型一般都是value的数据类型，key一般都是字符串


# 十大数据类型
## 字符串(String)
最基本的类型，一个key对应一个value
string是二进制安全的，意思是string可以包含任何数据，比如jpg或者序列化的对象

最基本的数据类型，最大的大小是512MB

## 列表(list)
简单的字符串列表，按照插入顺序排序，可以添加元素到list的头部或者尾部

**底层实现是一个双端列表**
最多可以包含2^32 -1 个元素

## 哈希（hash）
哈希是一个string类型的filed（字段）和value的**映射表**，hash特别适合用于存储对象

每一个hash可以存储2^32 -1 个键值对

## 集合（set）
set是string类型的无序集合。集合成员是唯一的，所以集合中不能出现重复元素。集合对象的编码可以是`intset`或者是`hashtable`

set底层是hash实现的，所以添加、删除、查找的复杂度都是O(1)

集合也是最多可以存储2^32 -1 个元素


## 有序集合（zset）
和set一样，都是集合，并且不允许出现重复元素

和set不一样的是，每一个元素都会关联一个double类型的分数，redis依靠这个分数来实现排序

zset成员唯一，但是分数可以重复

底层也是哈希表，最大容量也是2^32 -1

## 地理空间（GEO）
用于存储地理位置信息，并且对存储的地理位置信息进行操作
操作可以有：
* 添加地理位置坐标
* 获取地理位置坐标
* 计算两个位置之间的距离
* 根据用户给定的经纬度坐标来获取指定范围内的地理空间的集合

**这就是什么外卖、打车，什么附近的服务依赖的**


## 基数统计（HyperLogLog）
基数：不重复的元素

用来做基数统计的算法

优点是在输入元素的数量或者体积非常大的时候，计算基数所需的空间是固定的而且很小

每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。

但是它只会根据输入元素来计算基数，不会存储输入元素本身，所以不能像集合那样，返回输入的各个元素

**只适合做统计，不适合做记录**

**可以做网站的访问量统计，对访问的ip做记录**

## 位图（bitmap）
由0和1状态表现的二进制位的bit数组
![[Pasted image 20240705152058.png]]

**用来做签到、打卡、点赞标记**

可以节省空间，而且很适合做标记

## 位域（bitfield）
比特位域：连续的多个比特位

可以通过bitfield命令一次操作多个比特位域，它会执行一系列的操作并且返回以恶搞相应数组，这个数组中的元素对应参数列表中的相应操作的执行结果

人话：bitfield命令用来一次性对多个比特位域来操作

## 流（stream）
一个消息中间件

主要用于消息队列（Message Queue，MQ）

### 发布订阅模式的局限性
Redis本身有一个Redis发布订阅（pub/sub）来实现消息队列的功能的，但是这玩意消息无法持久化，如果连接不稳定或者redis挂了消息就丢了

简单说发布订阅这玩意可以传递消息，但是不能保存历史消息

### 流的优势
流的出现让redis可以持久化保存消息并且主从备份，可以让客户端访问任何时间的数据，并且记录每一个客户端的消息，还能保证消息不丢失


# 命令查询
[官网命令查询](https://redis.io/docs/latest/commands/)
[命令查询中文版]()

