# 介绍
对于特别大的数据集，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平拓展每个复制集只负责存储整个数据集的一部分，这就是Redis集群，其作用是提供在多个Redis节点间共享数据的程序集。

人话，单个数据集过大，对一个master的读取和写入压力过大。搞好几个master，让多个master平摊数据，减小单个Redis的压力

![[Pasted image 20240708205158.png]]

对于集群：
1. 数据分摊
2. 读写分离，master负责写，读则从slave中读

## 集群能干嘛
1. 集群支持多个Master，每个master又可以挂载多个slave，这又能实现读写分离
2. 由于Cluster（集群）自带Sentinel，直接就可以实现高可用，而不用再使用哨兵功能
3. 客户端和Redis的节点的连接，不再需要连接集群中的所有节点，只需要连接集群中的任意一个可用节点即可
4. 槽位（slot）负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系

# 集群算法
集群的节点数量推荐小于<1000
## 槽位（slot）
Redis集群没有使用一致性hash，而是引入了哈希槽。
Redis集群有16384个哈希槽，每个key通过CRC16校验之后，对16384取模，来决定放置在哪个槽。集群的每一个节点负责一部分hash槽。

如果一个集群有三个节点：
![[Pasted image 20240708210527.png]]

<span style="color:rgb(255, 0, 0)">也就是对key进行计算，算出这个key应该放在集群的哪个节点</span>

## 集群的分片
### 什么是分片
使用Redis集群时，我们会将存储的数据分散到多台Redis机器上，这就是分片。
简单的说，集群中的每一个Redis实例，都被认为是整个数据集的一个分片

### 如何找到key所在的分片
为了找到key的分片，我们对key进行CRC16算法处理，然后对这个结果对16384取模。然后使用确定性的hash函数，这样的话，同一个key就会始终映射到同一个分片。

<span style="color:rgb(255, 0, 0)">使用同样的确定性的算法对key进行计算来算出一个位置，不管是读取还是写入都使用这个位置，这样就保证了我们始终都能找到这个key了</span> 

### 分片的优势
1. 确定的读写位置
2. 方便扩容和缩容

这种结构很容易进行添加和删除节点。如果我们想要添加节点，只需要从别的节点分一部分槽位到新的节点上。如果我们想要移除一个节点，也只需要把这个节点的槽位移动到别的节点上。
因为一个节点移动hash槽并不会停止服务，只是改变数据的流向，所以无论是删除还是添加节点，都不会影响到Redis的服务

对于slot槽位映射，一般业界有三种方法：
1. 哈希取余分区
2. 一致性哈希算法分区
3. 哈希槽分区
#### 哈希取余分区
![[Pasted image 20240709095236.png]]

每次读写操作都是根据公式:
hash(key) % N 个机器台数，计算出哈希值，来决定数据映射到哪一个节点上

优点：
简单粗暴，很简单就能实现数据分流和负载均衡的目的

缺点：
不容易扩容或者缩容。不管是扩容还是所用，计算公式都要发生变化，所有的数据的映射关系都要重新计算


#### 一致性哈希算法分区
就是为了解决分布缓存数据变动和映射关系，也就是上面的缺点
##### 步骤
1. 算法构建一致性哈希环
2. 服务器IP节点映射
3. key落到服务器的落键规则


###### 一致性哈希算法分区
一致性hash算法将整个hash值空间组织成一个虚拟的圆环。这个环的hash值由小到大按照<span style="color:rgb(255, 0, 0)">顺时针分布</span>

依据这个圆环，我们对key进行hash运算，将其hash值映射到hash环中。

这样的话，key应该存储的位置计算公式由hash取余分区的 hash(key) % N
变成了 hash(key) % hash环大小

<span style="color:rgb(255, 0, 0)">hash环的大小和你使用的hash算法的值空间有关，和机器数无关</span>，这样就把机器数对存储位置的计算公式的影响排除掉了

###### redis服务器IP节点映射
将集群中的各个IP节点映射到环上的某一个位置。
映射方法也可以是对服务器的某个独一无二的标志进行hash运算后映射到哈希环上

大概映射之后就变成这样了
![[Pasted image 20240709102157.png]]

###### key落到服务器的落键规则
当我们需要存储一个kv键值对时，首先计算key的hash值，也即是hash（key），将这个key使用相同的hash函数计算出哈希值并且确定这个数据在环上的位置。从这个位置开始，<span style="color:rgb(255, 0, 0)">沿着环顺时针移动，第一个遇到的服务器</span>就是它应该存储到的服务器
![[Pasted image 20240709102743.png]]

##### 优缺点
优点：
具备容错性。某个服务器宕机之后，只需要在哈希环上下线，一个key只需要在hash环上<span style="color:rgb(255, 0, 0)">继续顺时针移动就可以找到下一个服务器</span>。

拥有扩展性。想要扩充节点，只需要在hash环上增加一个节点就可以了。符合要求的数据会自动找到这个一个服务器。对其他数据没有影响，不需要对其他数据进行重新计算


缺点：
存在数据倾斜问题。如果服务节点太少，或者节点分布不合理，<span style="color:rgb(255, 0, 0)">很容易出现大部分数据被缓存在一台服务器上</span>。
![[Pasted image 20240709103045.png]]

#### 哈希槽分区
哈希槽的数据分布公式：
HASH_SLOT = CRC16(key) mod 16384

哈希槽的出现就是为了解决一致性hash算法带来的数据倾斜问题。

哈希槽本质就是一个数组，数组\[0, 2^32-1]构成一个哈希槽空间

通过在数据和节点之间又<span style="color:rgb(255, 0, 0)">加上一层，哈希槽，用于管理数据和节点之间的关系</span>。相当于节点上放的是槽，槽里面放的才是数据。

槽把数据分布粒度放大了，这样就可以方便数据移动。哈希先计算数据应该放在哪一个槽中，而槽存储数据。

一个Redis集群最多有16384个槽，这个些槽被分配到集群中的所有主节点中，然后通过哈希槽的计算公式来计算数据应该放在哪一个槽中。
计算公式为：
HASH_SLOT = CRC16(key) mod 16384

#### 为什么槽的数量是16384个
为什么槽的数量是16384，而不是CRC16的数据空间范围65536？
1. 如果槽位数为65536个，发送的心跳信息的消息头高达8K，发送的心跳包过于巨大
源码实现原因：
![[Pasted image 20240709104800.png]]
这里这个myslots\[CLUSTER_SLOTS/8]。这一个结构体，当槽位为65536时，这个块的大小为65536 / 8 = 8KB

当槽位为16384时只有2KB

如果槽位