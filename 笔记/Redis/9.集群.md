# 介绍
对于特别大的数据集，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平拓展每个复制集只负责存储整个数据集的一部分，这就是Redis集群，其作用是提供在多个Redis节点间共享数据的程序集。

人话，单个数据集过大，对一个master的读取和写入压力过大。搞好几个master，让多个master平摊数据，减小单个Redis的压力

![[Pasted image 20240708205158.png]]

对于集群：
1. 数据分摊
2. 读写分离，master负责写，读则从slave中读

## 集群能干嘛
1. 集群支持多个Master，每个master又可以挂载多个slave，这又能实现读写分离
2. 由于Cluster（集群）自带Sentinel，直接就可以实现高可用，而不用再使用哨兵功能
3. 客户端和Redis的节点的连接，不再需要连接集群中的所有节点，只需要连接集群中的任意一个可用节点即可
4. 槽位（slot）负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系

# 集群算法
集群的节点数量推荐小于<1000
## 槽位（slot）
Redis集群没有使用一致性hash，而是引入了哈希槽。
Redis集群有16384个哈希槽，每个key通过CRC16校验之后，对16384取模，来决定放置在哪个槽。集群的每一个节点负责一部分hash槽。

如果一个集群有三个节点：
![[Pasted image 20240708210527.png]]

<span style="color:rgb(255, 0, 0)">也就是对key进行计算，算出这个key应该放在集群的哪个节点</span>

## 集群的分片
### 什么是分片
使用Redis集群时，我们会将存储的数据分散到多台Redis机器上，这就是分片。
简单的说，集群中的每一个Redis实例，都被认为是整个数据集的一个分片

### 如何找到key所在的分片
为了找到key的分片，我们对key进行CRC16算法处理，然后对这个结果对16384取模。然后使用确定性的hash函数，这样的话，同一个key就会始终映射到同一个分片。

<span style="color:rgb(255, 0, 0)">使用同样的确定性的算法对key进行计算来算出一个位置，不管是读取还是写入都使用这个位置，这样就保证了我们始终都能找到这个key了</span> 

### 分片的优势
1. 确定的读写位置
2. 方便扩容和缩容

这种结构很容易进行添加和删除节点。如果我们想要添加节点，只需要从别的节点分一部分槽位到新的节点上。如果我们想要移除一个节点，也只需要把这个节点的槽位移动到别的节点上。
因为一个节点移动hash槽并不会停止服务，只是改变数据的流向，所以无论是删除还是添加节点，都不会影响到Redis的服务

对于slot槽位映射，一般业界有三种方法：
1. 哈希取余分区
2. 一致性哈希算法分区
3. 哈希槽分区
#### 哈希取余分区
![[Pasted image 20240709095236.png]]

每次读写操作都是根据公式:
hash(key) % N 个机器台数，计算出哈希值，来决定数据映射到哪一个节点上

优点：
简单粗暴，很简单就能实现数据分流和负载均衡的目的

缺点：
不容易扩容或者缩容。不管是扩容还是所用，计算公式都要发生变化，所有的数据的映射关系都要重新计算