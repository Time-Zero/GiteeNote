可以一次执行多条命令，本质是一组命令的集合。一个事务中的所有命令都会被序列化，<span style="color:rgb(255, 0, 0)">按顺序地串行化执行而不会被其他命令插入，不被其他指令插入</span> 

一个队列中，一次性、顺序性、排他性的执行一系列命令

# 和关系型数据库之间的区别
![[Pasted image 20240707153321.png]]

# 如何使用
## 正常执行
```
# 启用事务
multi

普通语句

# 执行事务中的命令
exec

```

## 放弃事务
```
multi 

普通语句

# 放弃事务
discard
```


## 全体连坐
只要有出错的，全部失效

这个是在`multi`阶段，还没有`exec`之前，如果你的命令直接就有问题，在`multi`阶段就报错了，这时你`exec`会直接放弃这个事务

## 冤头债主
当`exec` 之后，你的一个命令出现了问题，出错的命令会执行错误，而没有问题的指令会被正确执行

如果在`exec`阶段出现了问题，是无法回滚的


## watch监控
Redis使用`watch`来提供乐观锁定，类似于CAS(Check and set)

* 悲观锁：每次拿数据的时候认为别人都会修改，所以每次拿数据的时候都会锁定数据
* 乐观锁：每次拿数据都认为别人不会更改，所以不会上锁，而是在更新的时候判断以下在此期间有没有人会更新这个数据。<span style="color:rgb(255, 0, 0)">我们提交的版本必须大于当前记录的版本</span> ，我们要提交的必须要比要修改的新


下面是一个标准的启用`watch`的过程
```
# 监控key
watch key

# 开启事务，并且可以在事务中修改key
multi

普通语句

exec
```

如果被<span style="color:rgb(255, 0, 0)">watch的数据被修改了，这个事务将会被整个中断</span>，会直接返回`nil`

### 放弃watch
在进入事务之前，执行`unwatch`就会放弃`watch`

```
watch key

unwatch key

multi

...

exec
```

这就会放弃事务。

<span style="color:rgb(255, 0, 0)">一旦`exec`之后，`watch`会被自动释放</span> 
一旦启用`watch`的客户端断开连接之后，这个客户端所有的`watch`也会被释放
