# 2.1 关系模型的数据结构及其形式化定义
## 2.1.1 关系
* 单一的数据结构——关系
	* 现实世界的实体以及实体间的各种联系均使用关系来表示
* 逻辑结构——二维表
	* 从用户的角度，关系模型中数据的逻辑结构是一张二维表
* 建立在集合代数的基础上
### 相关定义
#### 1. 域
一组具有相同数据类型的值的集合
例如：整数、实数、介于某个取值范围的整数、指定长度的字符串集合、{‘男’，‘女’}等。

#### 2. 笛卡尔积——基于域的一种运算
![[Pasted image 20240619201849.png]]
* 所有域的所有取值的一个组合
* 不能重复
* 笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组或简称**元组**。
* 笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个**分量**。
* ![[Pasted image 20240619202112.png]]

**以上内容我就看得懂一个域是什么意思**

#### 3.关系
![[Pasted image 20240619202157.png]]
R：关系名
n：关系的目或者读
关系也是一个二维表，表的**每一行对应一个元组**，表的**每一列对应一个域**

一行是一个实体
一列也就是这个属性的所能取的值的集合，所以也就是域

#### 4.属性
关系中的每一列必须取一个名字，称为属性（也就是列名），属性必须满足交换律，也就是列和列之间互换位置不影响（基本都遵循交换律）

#### 5.码
* 候选码：
	* 如果关系中的某一个属性组的值能够**唯一地标识一个元组**，而且没有多余的属性，就叫这个属性组为候选码（也就是能够作为主键的属性）
* 主码：
	* 如果一个关系存在多个候选码，选择其中一个作为主码
* 全码
	* 所有属性组共同组成的候选码 （什么意思？）
	* 意思就是没有没有没有任何一个属性可以作为候选码，所以只有整个属性组合起来才能唯一的表示某一个实体，这就是全码

#### 6.主属性域非主属性
包含在任一候选码的属性均为主属性，否则就是非主属性或者非码属性
简单的说，主要一个属性能当主键，就是主属性

#### 7.三类关系
* 基本关系（基本表）：实际存在的表
* 查询表：查询结果返回的表
* 视图表：基于基本表或者视图表创建的表，是虚表

#### 8.基本表的性质
1. 列是同质的（也就是一列都是一种数据类型）
2. 不同的列可以出自同一个域 （不同的列可以是一种数据类型）
3. 列的顺序无所谓，可以随意交换
4. 任意两个元组的候选码不能取相同的值（任意两个实体，能作为主码的属性取值不能相同，也就是拥有unique的约束）
5. 行的顺序无所谓
6. 分量必须取原子值，即每一个分量都是不可分的数据项

## 2.1.2 关系模式
关系模式是对关系的描述（关系模式是型，关系是值）=> 关系模式是对表的描述，关系模式是表的结构，关系是表中的数据

元组：其实就是行

* 元组集合的结构：
	* 属性的构成
	* 属性来自的域
	* 属性与域之间的映像关系
* 元组语义以及完整性约束条件
* 属性间的数据依赖关系集合


### 1. 关系模式的形式化表示
关系模式可以形式化的表示为
![[Pasted image 20240619203745.png]]

* R：关系名（表的名字）
* U：组成该关系的属性名集合（列名集合）
* D：属性组U中属性来自的域 （列的取值范围）
* DOM：属性向域的映像集合  （属性的类型和长度）
* F：属性间的数据依赖关系集合

### 2.关系模式的简化形式
![[Pasted image 20240619204021.png]]
* R：关系名（表名）
* A1,A2,A3....: 属性名

### 3.关系模式与关系
* 关系模式 （型）（表的结构）
	* 对关系的描述，静态的、稳定的 （对表的结构的描述）
* 关系 （值） （表中一行一行的数据）
	* 关系模式在某一时刻的状态或内容
	* 动态的、随时间不断变化的
* 关系模式和关系往往统称为关系，通过上下文加以区别 （？？不懂什么意思）


## 2.1.3 关系数据库
* 在一个给定的应用领域中，所有关系的集合构成一个关系数据库
（简称，长得跟个表似的）

# 2.2 关系模型的数据操作（表的数据操作）
## 2.2.1 关系操作的特点
* 集合操作方式：操作的对象和结果往往都是集合，一次一集合的方式

这也好理解，SQL的DQL语句本质就是一个对整个集合进行筛选的过程

## 2.2.2 常用的关系操作
* 查询：选择、投影、连接、并、除、交、差、笛卡尔积
* 数据更新：插入、删除、修改
* 选择、投影、并、差、笛卡尔积是五种基本操作
## 2.2.3 关系操作语言的分类
* 关系代数语言（对关系的运算）：ISBL
* 关系演算语言：使用为此来表达查询要求 
	* 元组关系演算语言：APLHA、QUEL
	* 域关系演算语言：QBE
* 具有关系代数和关系演算双重特点的语言：SQL

# 2.3 关系模型的完整性约束
关系的三类完整性：
* 实体完整性
* 参照完整性
* 用户定义的完整性
## 1. 实体完整性
如果属性A是是基本关系R的主属性，则属性A的取值必须唯一而且不能取空值
人话：主键的约束是 UNIQUE 并且 NOT NULL 的

## 2.参照完整性
若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：
* 或者取空值（F的每个属性值均为空值）
* 或者等于S中某个元组的主码值

人话：如果表的外键是别的表的主键，那么一行中，外键那一个空要么是NULL，要么是别的表的主键的值

## 3. 用户定义的完整性
* 针对莫伊具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足语义的要求
* 关系模型应该提供定义和检验这类完整性的机制，以便使用统一的系统的方法处理它们，而不要由应用程序承担这一功能

# 2.4 关系代数语言
* 传统的集合运算
	* 交、并、差、笛卡尔积
* 专门的关系运算
	* 选择、投影、连接、除
* 运算符
	* 算数运算符、逻辑运算符
## 2.4.1 传统的集合运算
### 1.并运算
就是两个集合合并
![[Pasted image 20240620100211.png]]

![[Pasted image 20240620100217.png]]

![[Pasted image 20240620100223.png]]

### 2. 交运算
集合间只取交叉项
![[Pasted image 20240620100254.png]]
![[Pasted image 20240620100313.png]]
![[Pasted image 20240620100322.png]]

### 3. 差运算
只取不同项
![[Pasted image 20240620100416.png]]

![[Pasted image 20240620100421.png]]

![[Pasted image 20240620100428.png]]

### 4. 广义笛卡尔积
项和项之间相乘
![[Pasted image 20240620100446.png]]

![[Pasted image 20240620100452.png]]

## 2.4.2 专门的关系运算
### 1.选择
在关系R中选择满足给定条件的元组，也就是按照条件筛选
![[Pasted image 20240620100743.png]]
![[Pasted image 20240620100718.png]]

例子：
![[Pasted image 20240620100758.png]]

### 2. 投影
从R中选择若干属性列组成新的关系 
人话：从表里面选择几列组成一个新的表
![[Pasted image 20240620100915.png]]
![[Pasted image 20240620100911.png]]

例子：
![[Pasted image 20240620100934.png]]

### 3. 连接
* 连接也叫条件连接
* 连接运算的含义：从两个关系的笛卡尔积中选取属性间满足一定条件的元组

人话：先求两个表的笛卡尔积，然后再使用条件筛选，其实也就是多表查询