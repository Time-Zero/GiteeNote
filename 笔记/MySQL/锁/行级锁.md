前置[[表级锁]]
# 介绍
行级锁，每次操作锁住对应的数据行，锁的粒度最小，发生冲突的概率最低，并发度最高，应用在InnoDB存储引擎当中

InnoDB的数据是基于索引组织的，行锁是对索引上的索引项加锁来实现的，而不是对记录进行加锁

行级锁分为三类：
* 行锁（记录锁）：锁定单个行记录的锁，防止其他事务对此进行update和delete，RC和RR隔离级别下都支持
* 间隙锁：锁定索引记录间隙（B+树的双向链表之间的间隙），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，出现幻读，在RR隔离级别下支持
* 零键锁：行锁和间隙锁组合，会锁住记录和间隙，在RR隔离级别下支持

# 行锁
 在InnoDB中提供了两种锁
 * 共享锁：允许一个事务去读取一行，阻止其他事务获得相同数据集的排他锁
 * 排他锁：允许获取排他锁的事务更新数据，其他与其他事务均互斥

`insert`、`update`、`delete`会自动加上排他锁
`select`(正常)不会加锁
`select ... lock in share mode`会主动加上共享锁
`select ... for update`会加上排他锁


## 注意

如果加锁的语句没有索引，就会对所有的记录加锁，则行级锁将升级为表锁
例如:
有表stu
id: 主键
name: 没有索引
则：
```SQL
begin;
update stu set name = '李华' where name = '张三'; 
commit;
```
则上面的`update`语句将会为表加上一个表锁，因为name字段没有索引，如果有索引则会对修改行加上一个行级互斥锁

# 间隙锁
默认情况下，IInnoDB在RR事务隔离级别下，使用next-key锁进行搜索和索引扫描，来防止幻读
* 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁
* 索引上的等职查询（普通索引），向右遍历时的最后一个值不满足查询需求时，next-key锁退化为间隙锁
* 索引上的范围查询（唯一索引），会访问到一个不满足条件的第一个值为止

简单的说，加间隙锁的情况有：
* 使用主键进行索引，索引的是不存在的内容，就会加间隙锁，锁的是两个索引间的间隙
* 使用非主键索引，使用等值查询时，会对等值结果相邻的第一不等值结果之间的间隙加锁
* 使用唯一索引，进行范围查询，对第一个不满足索引记录的记录，这个加的是临界锁，对一个范围加锁