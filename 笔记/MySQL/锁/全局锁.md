先看看[[B+树]]会对这块有更好的理解，很多锁的建立都是建立在B+树上的，锁要么锁整个树，要么锁一个记录，要么锁一个间隙
# 介绍
对整个数据的所有表加锁，加锁之后整个实例处于只读状态，不允许修改和创建

一般用于数据的全库备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

# 操作
## 加锁
首先切换到对应的数据库
```SQL
use 数据库名;
flush tables with read lock;
```
这样当前的数据库就只能够读取，而不能写入和修改

## 解锁
```SQL
use 数据库名;
unlock tables;
```
这样就释放了全局锁

## 被锁后的反应
被锁后，你的写入和修改并不会报错，而是会被阻塞。
原理也很简单，全局锁实际就是对数据库每张表加了一个读锁，所以你的写入和修改操作的反馈和普通的读取锁是一样的

# 弊端
## 锁的粒度和影响较大
* 如果在主库上备份，则备份期间不能执行更新，基本上所有的依赖于这个锁的业务都得停摆
* 如果在从库上备份，则在备份期间不能执行主库同步过来的二进制日志，会导致主从延迟

## 解决方案
如果是`InnoDB`引擎，可以在备份时加上参数`--single-transaction`参数来完成不加锁的一致性数据备份

这个底层依赖的是对当前数据库的快照来实现的
