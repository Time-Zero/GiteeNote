前置[[全局锁]]
# 介绍
每次操作锁住整张表，锁定的粒度大，发生冲突的概率高，并发度最低，应用在MyISAM、InnoDB和BDB等存储引擎中

对于表级锁，分为以下三类：
* 表锁
* 元数据锁
* 意向锁

# 表锁
表锁又分为：
* 表共享读锁（读锁）
* 表独占写锁（写锁）

## 语法
加锁，一次可以对多张表加锁
```SQL
lock tables 表名,... read/write
```

解锁
```SQL
unlock tables 表名
```
其实当客户端断开连接，也会释放当前会话中的锁


## 读锁
读锁一旦加上，所有的会话不允许对加锁的表进行写入操作，不同会话的写入操作反应不同
* 对于创建锁的会话，修改行为会报错
* 对于非创建锁的会话，修改行为会被阻塞
但是允许多个会话同时读取
```SQL
lock tabls 表名,.... read;
```


## 写锁
写锁加上后，加锁的会话允许读取和写入，非加锁的会话的读取和写入操作会被阻塞

```SQL
lock tabls 表名，... write;
```

# 元数据锁
 元数据锁在加锁过程中由系统自动控制，无需手动加锁，当我们访问一张表时会自动加上。
 
## 元数据
表的元数据实际就是表的结构

元数据锁的意义就是在表上由活动事务时，不允许修改表的结构，防止我们未提交的事务中的DML语句和表的DDL语句之间发生冲突

当表存在未提交的事务时，我们修改表的结构的操作将会被阻塞


# 意向锁
意向锁的出现是为了解决行锁和表锁之间的冲突问题

当对表加表锁时，数据库会遍历整个表，来看看每一行有没有被加锁，这个性能非常的低下，为了解决这个问题，提出了意向锁，让表锁不用对表进行检查，而是检查表的意向锁

当表的意向锁和要加的表锁兼容，则表锁成功
如果不兼容，则表锁操作被阻塞

## 分类
* 意向共享锁：由语句`select ... lock in share mode`添加，和表锁中的读锁兼容，写锁互斥
* 意向排他锁：由`insert`,`update`,`delete`,`select...for update`添加，和表锁完全互斥

**意向锁之间不会互斥**



